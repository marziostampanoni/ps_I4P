<?php
/*
 * This file is part of Moodle - http://moodle.org/
 * Moodle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moodle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
 */

/** 
 * Definition of the factory that allows to create web service instances.
 *
 * @package    enrol_usi
 * @copyright  2014 Guglielmo Fachini {@link http://fachini.net}
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace enrol_usi\ws;

// moodle requirements
require_once("$CFG->dirroot/config.php");

class factory {

    /** 
     * @var closure the closure from which the Web Service instances are generated.
     */
    private static $generator;

    /**
     * Inject a generator of Web Services in the factory.
     * After the execution of that method, all the requested Web Service instances
     * will be generated by the injected generator.
     * 
     * @param a closure that accepts the parameters needed to create an instance 
     *        of the Web Service.
     */
    public static function inject($generator) {
        factory::$generator = $generator; 
    }

    /**
     * Inject a Web Service object.
     * This is method is similar to 'inject' because it injects something to 
     * return when a web service instance is requested. The main difference is 
     * that 'inject' accepts a Closure that each time returns a new instance, 
     * while this method accepts an object that is always returned when the 
     * 'generate' method is called.
     * This is a sort of 'singleton' object injection.
     *
     * @param the object to inject
     */
    public static function inject_object($object) {
        factory::inject(function ($wsdl_location, $api_key) use ($object) {
            return $object;
        });
    }

    /**
     * The type of the returned instance is decided based on the settings 
     * defined in the relative plugin moodle's page. 
     *
     * @return usi_ws the default Web Service class instance
     */
    public static function create() {
        // retrieve from the plugin settings the WSDL location and the API key
        $wsdl_location = get_config('enrol_usi', 'usi_wsdl_location');
        $api_key = get_config('enrol_usi', 'usi_ws_key');

        // check if it's required the cached version of the Web Service
        $cached_version = get_config('enrol_usi', 'cached_ws_flag');

        // return the proper WS implementation
        if ($cached_version == 1) { 
            // retrieve the cache TTL seconds (when does a record get older?)
            $cacheTTL = get_config('enrol_usi', 'cache_ttl');

            // create an instance of the cache
            $cache = new module_cache($cacheTTL * 60 * 60);

            return factory::create_cached_ws($wsdl_location, $api_key, $cache);
        } else {
            return factory::create_concrete_ws($wsdl_location, $api_key);
        }
    }

    /**
     * @param the location of the WSDL file
     * @param the api key used for the authentication
     *
     * @return usi_ws the instance of the Web Service accordingly to the fact that it 
     *         can be an injected closure that generates a fake web service.
     */
    private static function generate($wsdl_location, $api_key) {
        // if nothing has been injected, return the default Web Service 
        // implementation
        if (is_null(factory::$generator)) {
            return concrete_ws::create($wsdl_location, $api_key);
        }

        // otherwise, return the injected implementation
        return factory::$generator->__invoke($wsdl_location, $api_key);
    }

    /**
     * Create and return the instance of the concrete Web Service class.
     *
     * @return concrete_ws the instance of the concrete Web Service class
     */
    private static function create_concrete_ws($wsdl_location, $api_key) {
        return factory::generate($wsdl_location, $api_key);
    }

    /**
     * Create and return the instance of the cached Web Servic class.
     *
     * @return cached_ws the instance of the cached Web service class
     */
    private static function create_cached_ws($wsdl_location, $api_key, $cacheTTL) {
        return cached_ws::create($wsdl_location, $api_key, $cacheTTL);
    }
}

