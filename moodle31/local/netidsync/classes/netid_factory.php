<?php
/*
 * This file is part of Moodle - http://moodle.org/
 * Moodle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moodle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
 */

namespace local_netidsync;

/**
 * This class allows to retrieve an instance of the netid class. 
 *
 * @package    local_netidsync
 * @copyright  2014 Guglielmo Fachini {@link http://fachini.net}
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class netid_factory {

    /** 
     * @var closure the closure from which the NetID handler instances are generated.
     */
    private static $generator;

    /**
     * Inject a generator of NetID in the factory.
     * After the execution of that method, all the requested NetID instances
     * will be generated by the injected generator.
     * 
     * @param a closure that accepts the parameters needed to create an instance 
     *        of the NetID.
     */
    public static function inject($generator) {
        netid_factory::$generator = $generator; 
    }

    /**
     * Inject a NetID object.
     * This is method is similar to 'inject' because it injects something to 
     * return when a NetID instance is requested. The main difference is 
     * that 'inject' accepts a Closure that each time returns a new instance, 
     * while this method accepts an object that is always returned when the 
     * 'generate' method is called.
     * This is a sort of 'singleton' object injection.
     *
     * @param the object to inject
     */
    public static function inject_object($object) {
        netid_factory::inject(function ($host, $port, $binddn, $password, $protocol_version, $dcs) use ($object) {
            return $object;
        });
    }

    /**
     * @return netid a new instance of the netid class
     */
    public static function create() {
        // retrieve the LDAP parameters from the plugin settings
        $host = get_config('local_netidsync', 'ldap_host');
        $port = get_config('local_netidsync', 'ldap_port');
        $binddn = get_config('local_netidsync', 'ldap_binddn');
        $password = get_config('local_netidsync', 'ldap_password');
        $protocol_version = get_config('local_netidsync', 'ldap_protocol_version');
		
		// extract the domain components from the raw config value
		$raw_dcs = get_config('local_netidsync', 'ldap_domain_components');
		$dcs = explode(',', $raw_dcs);	

        // return a new instance of the netid class
		return netid_factory::generate($host, $port, $binddn, $password, $protocol_version, $dcs);
    }

    /**
     * @return netid the instance of a NetID accordingly to the fact that it 
     *         can be an injected closure that generates a fake NetID.
     */
    private static function generate($host, $port, $binddn, $password, $protocol_version, $dcs) {
        // if nothing has been injected, return the default NetID 
        // implementation
        if (is_null(netid_factory::$generator)) {
			return new netid($host, $port, $binddn, $password, $protocol_version, $dcs);
        }

        // otherwise, return the injected implementation
        return netid_factory::$generator->__invoke($host, $port, $binddn, $password, $protocol_version, $dcs);
    }
}

